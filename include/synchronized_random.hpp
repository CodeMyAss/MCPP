/**
 *	\file
 */
 
 
#pragma once


#include <rleahylib/rleahylib.hpp>
#include <scope_guard.hpp>
#include <type_traits>
#include <utility>


namespace MCPP {


	/**
	 *	Provides a thread safe wrapper for random
	 *	number sources.
	 */
	template <typename T>
	class SynchronizedRandom {
	
	
		private:
		
		
			T func;
			Mutex lock;
			
			
		public:
		
		
			typedef typename T::result_type result_type;
			
			
			SynchronizedRandom () = default;
			
			
			/**
			 *	Wraps a random number source in a thread
			 *	safe wrapper.
			 *
			 *	\param [in] func
			 *		The object to wrap.
			 */
			SynchronizedRandom (T func) noexcept(
				std::is_nothrow_move_constructible<T>::value
			) : func(std::move(func)) {	}
			
			
			/**
			 *	Produces a random number in a thread safe
			 *	manner.
			 *
			 *	\return
			 *		A random number from the underlying
			 *		random number source.
			 */
			template <typename... Args>
			result_type operator () (Args &&... args) noexcept(
				noexcept(std::declval<T>()(std::forward<Args>(args)...))
			) {
			
				lock.Acquire();
				auto guard=AtExit([&] () noexcept {	lock.Release();	});
				return func(std::forward<Args>(args)...);
			
			}
			
			
			/**
			 *	Returns the minimum value that will be
			 *	generated by the underlying object.
			 *
			 *	\return
			 *		The lowest value the underlying
			 *		object will produce.
			 */
			result_type min () noexcept(
				noexcept(std::declval<T>().min())
			) {
			
				return func.min();
			
			}
			
			
			/**
			 *	Returns the maximum value that will
			 *	be generated by the underlying
			 *	object.
			 *
			 *	\return
			 *		The highest value the underlying
			 *		object will produce.
			 */
			result_type max () noexcept(
				noexcept(std::declval<T>().max())
			) {
			
				return func.max();
			
			}
	
	
	};


}
